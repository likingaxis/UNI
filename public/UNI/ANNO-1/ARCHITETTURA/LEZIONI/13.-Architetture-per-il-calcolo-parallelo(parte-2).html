<!DOCTYPE html>
<html lang="en" dir="ltr"><head><title>13. Architetture per il calcolo parallelo(parte 2)</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;family=IBM Plex Mono:wght@400;600&amp;display=swap"/><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="Quartz 4"/><meta property="og:title" content="13. Architetture per il calcolo parallelo(parte 2)"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="13. Architetture per il calcolo parallelo(parte 2)"/><meta name="twitter:description" content="cosa è lo scheduling? È la pianificazione e gestione delle risorse come attività, processi e informazioni nel caso della CPU lo scheduler ad esempio mette in ordine i processi a seconda delle priorità mettendo una determinata capacità di risorse della CPU ad ogni processo a seconda delle loro neces..."/><meta property="og:description" content="cosa è lo scheduling? È la pianificazione e gestione delle risorse come attività, processi e informazioni nel caso della CPU lo scheduler ad esempio mette in ordine i processi a seconda delle priorità mettendo una determinata capacità di risorse della CPU ad ogni processo a seconda delle loro neces..."/><meta property="og:image:alt" content="cosa è lo scheduling? È la pianificazione e gestione delle risorse come attività, processi e informazioni nel caso della CPU lo scheduler ad esempio mette in ordine i processi a seconda delle priorità mettendo una determinata capacità di risorse della CPU ad ogni processo a seconda delle loro neces..."/><meta property="twitter:domain" content="quartz.jzhao.xyz"/><meta property="og:url" content="https://quartz.jzhao.xyz/UNI/ANNO-1/ARCHITETTURA/LEZIONI/13.-Architetture-per-il-calcolo-parallelo(parte-2)"/><meta property="twitter:url" content="https://quartz.jzhao.xyz/UNI/ANNO-1/ARCHITETTURA/LEZIONI/13.-Architetture-per-il-calcolo-parallelo(parte-2)"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="cosa è lo scheduling? È la pianificazione e gestione delle risorse come attività, processi e informazioni nel caso della CPU lo scheduler ad esempio mette in ordine i processi a seconda delle priorità mettendo una determinata capacità di risorse della CPU ad ogni processo a seconda delle loro neces..."/><meta name="generator" content="Quartz"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><style>.expand-button {
  position: absolute;
  display: flex;
  float: right;
  padding: 0.4rem;
  margin: 0.3rem;
  right: 0;
  color: var(--gray);
  border-color: var(--dark);
  background-color: var(--light);
  border: 1px solid;
  border-radius: 5px;
  opacity: 0;
  transition: 0.2s;
}
.expand-button > svg {
  fill: var(--light);
  filter: contrast(0.3);
}
.expand-button:hover {
  cursor: pointer;
  border-color: var(--secondary);
}
.expand-button:focus {
  outline: 0;
}

pre:hover > .expand-button {
  opacity: 1;
  transition: 0.2s;
}

#mermaid-container {
  position: fixed;
  contain: layout;
  z-index: 999;
  left: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: none;
  backdrop-filter: blur(4px);
  background: rgba(0, 0, 0, 0.5);
}
#mermaid-container.active {
  display: inline-block;
}
#mermaid-container > #mermaid-space {
  border: 1px solid var(--lightgray);
  background-color: var(--light);
  border-radius: 5px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  height: 80vh;
  width: 80vw;
  overflow: hidden;
}
#mermaid-container > #mermaid-space > .mermaid-content {
  padding: 2rem;
  position: relative;
  transform-origin: 0 0;
  transition: transform 0.1s ease;
  overflow: visible;
  min-height: 200px;
  min-width: 200px;
}
#mermaid-container > #mermaid-space > .mermaid-content pre {
  margin: 0;
  border: none;
}
#mermaid-container > #mermaid-space > .mermaid-content svg {
  max-width: none;
  height: auto;
}
#mermaid-container > #mermaid-space > .mermaid-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 8px;
  padding: 8px;
  background: var(--light);
  border: 1px solid var(--lightgray);
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 2;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  border: 1px solid var(--lightgray);
  background: var(--light);
  color: var(--dark);
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  font-family: var(--bodyFont);
  transition: all 0.2s ease;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:hover {
  background: var(--lightgray);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:active {
  transform: translateY(1px);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:nth-child(2) {
  width: auto;
  padding: 0 12px;
  font-size: 14px;
}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiQzpcXFVzZXJzXFxMdWNhXFxEZXNrdG9wXFxVTkkgTlVPVk9cXHF1YXJ0elxccXVhcnR6XFxjb21wb25lbnRzXFxzdHlsZXMiLCJzb3VyY2VzIjpbIm1lcm1haWQuaW5saW5lLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7O0FBR0Y7RUFDRTtFQUNBOztBQUdGO0VBQ0U7OztBQUtGO0VBQ0U7RUFDQTs7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7O0FBR0Y7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTs7QUFHRjtFQUNFO0VBQ0E7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFOztBQUdGO0VBQ0U7O0FBSUY7RUFDRTtFQUNBO0VBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIuZXhwYW5kLWJ1dHRvbiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxvYXQ6IHJpZ2h0O1xuICBwYWRkaW5nOiAwLjRyZW07XG4gIG1hcmdpbjogMC4zcmVtO1xuICByaWdodDogMDsgLy8gTk9URTogcmlnaHQgd2lsbCBiZSBzZXQgaW4gbWVybWFpZC5pbmxpbmUudHNcbiAgY29sb3I6IHZhcigtLWdyYXkpO1xuICBib3JkZXItY29sb3I6IHZhcigtLWRhcmspO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodCk7XG4gIGJvcmRlcjogMXB4IHNvbGlkO1xuICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zaXRpb246IDAuMnM7XG5cbiAgJiA+IHN2ZyB7XG4gICAgZmlsbDogdmFyKC0tbGlnaHQpO1xuICAgIGZpbHRlcjogY29udHJhc3QoMC4zKTtcbiAgfVxuXG4gICY6aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLXNlY29uZGFyeSk7XG4gIH1cblxuICAmOmZvY3VzIHtcbiAgICBvdXRsaW5lOiAwO1xuICB9XG59XG5cbnByZSB7XG4gICY6aG92ZXIgPiAuZXhwYW5kLWJ1dHRvbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2l0aW9uOiAwLjJzO1xuICB9XG59XG5cbiNtZXJtYWlkLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgY29udGFpbjogbGF5b3V0O1xuICB6LWluZGV4OiA5OTk7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMHZ3O1xuICBoZWlnaHQ6IDEwMHZoO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBkaXNwbGF5OiBub25lO1xuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjUpO1xuXG4gICYuYWN0aXZlIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIH1cblxuICAmID4gI21lcm1haWQtc3BhY2Uge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbGlnaHQpO1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiA1MCU7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIGhlaWdodDogODB2aDtcbiAgICB3aWR0aDogODB2dztcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgJiA+IC5tZXJtYWlkLWNvbnRlbnQge1xuICAgICAgcGFkZGluZzogMnJlbTtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2U7XG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xuICAgICAgbWluLXdpZHRoOiAyMDBweDtcblxuICAgICAgcHJlIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIHN2ZyB7XG4gICAgICAgIG1heC13aWR0aDogbm9uZTtcbiAgICAgICAgaGVpZ2h0OiBhdXRvO1xuICAgICAgfVxuICAgIH1cblxuICAgICYgPiAubWVybWFpZC1jb250cm9scyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IDIwcHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDhweDtcbiAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgIGJhY2tncm91bmQ6IHZhcigtLWxpZ2h0KTtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICAgICAgei1pbmRleDogMjtcblxuICAgICAgLm1lcm1haWQtY29udHJvbC1idXR0b24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGhlaWdodDogMzJweDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHQpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZGFyayk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1ib2R5Rm9udCk7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2U7XG5cbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0eWxlIHRoZSByZXNldCBidXR0b24gZGlmZmVyZW50bHlcbiAgICAgICAgJjpudGgtY2hpbGQoMikge1xuICAgICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICAgIHBhZGRpbmc6IDAgMTJweDtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ== */</style><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../../../../static/contentIndex.json").then(data => data.json())</script><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://quartz.jzhao.xyz/index.xml"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image" content="https://quartz.jzhao.xyz/UNI/ANNO-1/ARCHITETTURA/LEZIONI/13.-Architetture-per-il-calcolo-parallelo(parte-2)-og-image.webp"/><meta property="og:image:url" content="https://quartz.jzhao.xyz/UNI/ANNO-1/ARCHITETTURA/LEZIONI/13.-Architetture-per-il-calcolo-parallelo(parte-2)-og-image.webp"/><meta name="twitter:image" content="https://quartz.jzhao.xyz/UNI/ANNO-1/ARCHITETTURA/LEZIONI/13.-Architetture-per-il-calcolo-parallelo(parte-2)-og-image.webp"/><meta property="og:image:type" content="image/.webp"/></head><body data-slug="UNI/ANNO-1/ARCHITETTURA/LEZIONI/13.-Architetture-per-il-calcolo-parallelo(parte-2)"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href="../../../..">Quartz 4</a></h2><div class="spacer mobile-only"></div><div class="flex-component" style="flex-direction: row; flex-wrap: nowrap; gap: 1rem;"><div style="flex-grow: 1; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><div class="search"><button class="search-button"><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg><p>Search</p></button><div class="search-container"><div class="search-space"><input autocomplete="off" class="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div class="search-layout" data-preview="true"></div></div></div></div></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="readermode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="readerIcon" fill="currentColor" stroke="currentColor" stroke-width="0.2" stroke-linecap="round" stroke-linejoin="round" width="64px" height="64px" viewBox="0 0 24 24" aria-label="Reader mode"><title>Reader mode</title><g transform="translate(-1.8, -1.8) scale(1.15, 1.2)"><path d="M8.9891247,2.5 C10.1384702,2.5 11.2209868,2.96705384 12.0049645,3.76669482 C12.7883914,2.96705384 13.8709081,2.5 15.0202536,2.5 L18.7549359,2.5 C19.1691495,2.5 19.5049359,2.83578644 19.5049359,3.25 L19.5046891,4.004 L21.2546891,4.00457396 C21.6343849,4.00457396 21.9481801,4.28672784 21.9978425,4.6528034 L22.0046891,4.75457396 L22.0046891,20.25 C22.0046891,20.6296958 21.7225353,20.943491 21.3564597,20.9931534 L21.2546891,21 L2.75468914,21 C2.37499337,21 2.06119817,20.7178461 2.01153575,20.3517706 L2.00468914,20.25 L2.00468914,4.75457396 C2.00468914,4.37487819 2.28684302,4.061083 2.65291858,4.01142057 L2.75468914,4.00457396 L4.50368914,4.004 L4.50444233,3.25 C4.50444233,2.87030423 4.78659621,2.55650904 5.15267177,2.50684662 L5.25444233,2.5 L8.9891247,2.5 Z M4.50368914,5.504 L3.50468914,5.504 L3.50468914,19.5 L10.9478955,19.4998273 C10.4513189,18.9207296 9.73864328,18.5588115 8.96709342,18.5065584 L8.77307039,18.5 L5.25444233,18.5 C4.87474657,18.5 4.56095137,18.2178461 4.51128895,17.8517706 L4.50444233,17.75 L4.50368914,5.504 Z M19.5049359,17.75 C19.5049359,18.1642136 19.1691495,18.5 18.7549359,18.5 L15.2363079,18.5 C14.3910149,18.5 13.5994408,18.8724714 13.0614828,19.4998273 L20.5046891,19.5 L20.5046891,5.504 L19.5046891,5.504 L19.5049359,17.75 Z M18.0059359,3.999 L15.0202536,4 L14.8259077,4.00692283 C13.9889509,4.06666544 13.2254227,4.50975805 12.7549359,5.212 L12.7549359,17.777 L12.7782651,17.7601316 C13.4923805,17.2719483 14.3447024,17 15.2363079,17 L18.0059359,16.999 L18.0056891,4.798 L18.0033792,4.75457396 L18.0056891,4.71 L18.0059359,3.999 Z M8.9891247,4 L6.00368914,3.999 L6.00599909,4.75457396 L6.00599909,4.75457396 L6.00368914,4.783 L6.00368914,16.999 L8.77307039,17 C9.57551536,17 10.3461406,17.2202781 11.0128313,17.6202194 L11.2536891,17.776 L11.2536891,5.211 C10.8200889,4.56369974 10.1361548,4.13636104 9.37521067,4.02745763 L9.18347055,4.00692283 L8.9891247,4 Z"></path></g></svg></button></div></div><div class="explorer" data-behavior="link" data-collapsed="collapsed" data-savestate="true" data-data-fns="{&quot;order&quot;:[&quot;filter&quot;,&quot;map&quot;,&quot;sort&quot;],&quot;sortFn&quot;:&quot;(a,b)=>!a.isFolder&amp;&amp;!b.isFolder||a.isFolder&amp;&amp;b.isFolder?a.displayName.localeCompare(b.displayName,void 0,{numeric:!0,sensitivity:\&quot;base\&quot;}):!a.isFolder&amp;&amp;b.isFolder?1:-1&quot;,&quot;filterFn&quot;:&quot;node=>node.slugSegment!==\&quot;tags\&quot;&quot;,&quot;mapFn&quot;:&quot;node=>node&quot;}"><button type="button" class="explorer-toggle mobile-explorer hide-until-loaded" data-mobile="true" aria-controls="explorer-74"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button><button type="button" class="title-button explorer-toggle desktop-explorer" data-mobile="false" aria-expanded="true"><h2>Explorer</h2><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-74" class="explorer-content" aria-expanded="false" role="group"><ul class="explorer-ul overflow" id="list-0"><li class="overflow-end"></li></ul></div><template id="template-file"><li><a href="#"></a></li></template><template id="template-folder"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div><button class="folder-button"><span class="folder-title"></span></button></div></div><div class="folder-outer"><ul class="content"></ul></div></li></template></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../../../../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../../UNI/">UNI</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../../UNI/ANNO-1/">ANNO 1</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../../UNI/ANNO-1/ARCHITETTURA/">ARCHITETTURA</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../../../UNI/ANNO-1/ARCHITETTURA/LEZIONI/">LEZIONI</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>13. Architetture per il calcolo parallelo(parte 2)</a></div></nav><h1 class="article-title">13. Architetture per il calcolo parallelo(parte 2)</h1><p show-comma="true" class="content-meta"><time datetime="2025-10-13T15:42:40.000Z">Oct 13, 2025</time><span>18 min read</span></p></div></div><article class="popover-hint"><blockquote class="callout info is-collapsible is-collapsed" data-callout="info" data-callout-fold>
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>cosa è lo scheduling? </p></div>
                  <div class="fold-callout-icon"></div>
                </div>
<div class="callout-content">
<p>È la pianificazione e gestione delle risorse come attività, processi e informazioni
nel caso della CPU lo scheduler ad esempio mette in ordine i processi a seconda delle priorità mettendo una determinata capacità di risorse della CPU ad ogni processo a seconda delle loro necessità e priorità(ad esempio hai brave e discord aperto, lo scheduler dice alla CPU di dare il 30% delle risorse a brave e il 20% a discord), lo scheduler inoltre dà un tot di tempo alla CPU per eseguire il processo</p>
</div>
</blockquote>
<h1 id="scheduling-dei-multiprocessori">Scheduling dei multiprocessori<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#scheduling-dei-multiprocessori" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Lo scheduler può essere mono-dimensionale o bi-dimensionale
nel caso del mono-dimensionale hai solo una CPU quindi lo scheduler deve solo decidere quale processo avviare
invece nel caso bi-dimensionale lo scheduler deve decidere quale processo avviare e quale CPU utilizzare</p>
<p>Esistono vari algoritmi di scheduling per ciascuna situazione:</p>
<ul>
<li>
<p>timesharing</p>
</li>
<li>
<p>condivisione dello spazio</p>
</li>
<li>
<p>schedulazione gang</p>
</li>
</ul>
<p>partiamo dal primo</p>
<h3 id="time-sharing">TIME SHARING<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#time-sharing" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>È utilizzato quando i processi sono indipendenti(non lavora con delle risorse che esegue un altro processo)
l’algoritmo usa un vettore che contiene tutti i processi che sono nello stato “ready” quindi sono pronti per partire, con diverse priorità di esecuzione
avendo un unica struttura dati  e dei processi indipendenti tutte le CPU sono perfettamente bilanciate e non ci sarà mai una CPU oberata da lavoro mentre un’altra è inattiva come se fosse un sistema monoprocessore
problemi:</p>
<ol>
<li>se hai troppe CPU tutte vogliono accedere alla struttura dati(il vettore)</li>
<li>quando una delle CPU deve fare un’operazione di I/O che richiede del tempo, oltre ad essere innescato lo spin lock, avviene un cambio di contesto, ovvero la CPU deve passare dall’esecuzione del processo che stava eseguendo a un altro processo ad esempio di attesa dell’I/O. Il problema è quando tutti i processi entrano in questo stato e iniziano ad essere sovraccarichi di lavoro</li>
</ol>
<blockquote class="callout info is-collapsible is-collapsed" data-callout="info" data-callout-fold>
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>cosa è lo spin lock </p></div>
                  <div class="fold-callout-icon"></div>
                </div>
<div class="callout-content">
<p>È un meccanismo di protezione che aiuta la sincronizzazione tra le risorse delle CPU evitando che
n CPU interagiscano con la stessa cosa. si divide in due stati:</p>
<ul>
<li>l’attesa(spin) è quando la risorsa è in attesa di avere interazioni</li>
<li>il lock(il blocco della risorsa) è quando la risorsa è bloccata a tutte le altre CPU perché sta
avendo una interazione</li>
</ul>
</div>
</blockquote>
<p><img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513123941.png" width="auto" height="auto" alt/>
Quando una CPU ci mette troppo tempo e quindi termina il quantum di tempo dato dallo scheduler, la CPU quindi ancora deve rilasciare il lock, la CPU può accedere un tempo extra quindi un extra quantum, questa operazione viene chiamata <strong>smart scheduling</strong>.</p>
<p>L’affinity scheduling fa eseguire il medesimo processo alla CPU che già lo ha eseguito in passato così da sfruttare i dati nella cache
per creare questa affinità si utilizza un algoritmo di schedulazione a 2 livelli:</p>
<ol>
<li>scheduling ad alto livello, vengono messi i processi con elevata priorità e vengono assegnati alle CPU che in quel momento sono inutilizzate</li>
<li>scheduling a basso livello, viene fatto uno scheduling assegnando il processo in base all’affinità della cache e delle priorità, comportando un miglioramento delle performance generali
questa cosa dà un carico equo alle CPU
le liste di processi vengono usate meno perché alle CPU vengono assegnati compiti che già conoscono</li>
</ol>
<h3 id="space-sharing-scheduling">SPACE SHARING SCHEDULING<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#space-sharing-scheduling" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Quando ci sono correlazioni tra i vari processi si può usare lo scheduling per condivisione di spazio
cosa succede?
il processo viene suddiviso in tanti piccoli thread e lo scheduler assegna n thread a n CPU.
Essendo processi complementari lo scheduler avvierà i processi una volta che ci saranno disponibili n CPU libere, quindi se il processo richiede 10 thread e ci sono 9 CPU disponibili lo scheduler non farà eseguire nulla
vantaggio:
riduce gli overhead, perché le CPU sono libere di accedere alla memoria senza troppi conflitti
problema:
quando le CPU non sono libere si perde tempo nell’attesa che si liberino</p>
<blockquote class="callout info is-collapsible is-collapsed" data-callout="info" data-callout-fold>
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>overhead cosa è? </p></div>
                  <div class="fold-callout-icon"></div>
                </div>
<div class="callout-content">
<p>Quelle risorse in più all’interno di un processo, ad esempio in un cambio di contesto in mezzo ai due processi c’è il cambio stesso, quindi una risorsa in più</p>
</div>
</blockquote>
<p><img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513124016.png" width="auto" height="auto" alt/></p>
<h3 id="schedulazione-gang">SCHEDULAZIONE GANG<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#schedulazione-gang" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Nasce dal bisogno di schedulare insieme risorse(spazio) e tempo
si compone in 3 passaggi:</p>
<ul>
<li>si creano tanti piccoli gruppi di thread correlati chiamate unità o gang</li>
<li>tutti i thread di una gang vengono eseguiti assieme su diverse CPU con il sistema di timesharing</li>
<li>tutti i thread della gang iniziano e terminano assieme
questo sistema funziona perché ogni CPU è scandita da un quanto ben definito e discreto, dopo che il quantum termina alle CPU viene fatta nuovamente l’operazione di scheduling e se un thread si blocca, la sua CPU rimane inattiva fino allo fine del quanto
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513130449.png" width="auto" height="auto" alt/></li>
</ul>
<p>Tutti i thread vengono eseguiti contemporaneamente a seconda di uno scheduling fatto e in un determinato quantum di tempo.
Ciò permette anche lo scambio di informazioni immediate tra le varie CPU di risorse necessarie e condivise
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513130807.png" width="auto" height="auto" alt/></p>
<h2 id="multicomputer">MULTICOMPUTER<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#multicomputer" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Ogni CPU del multicomputer si interfaccia con la sua memoria privata con LOAD e STORE ma per scambiare informazioni con altre CPU usano send receive attraverso rete di interconnessione</p>
<ol>
<li>una CPU è interessata ai dati di un’altra CPU</li>
<li>dopo aver scoperto quale CPU possiede i dati che le interessano le spedisce una richiesta di copia dei dati. Di norma questa operazione blocca la CPU finché la richiesta non viene soddisfatta.</li>
<li>la richiesta arriva alla CPU 1, il suo software lo analizza e restituire i dati richiesti.  la CPU 0 riceve il messaggio di risposta, il suo software si sblocca e continua l’esecuzione.
 I processori di comunicazione sono collegati tramite una rete ad alta velocità.
quando un programma applicativo esegue una primitiva send il processore di comunicazione riceve una notifica e si incarica di trasmettere il blocco di dati dell’utente presso la macchina di destinazione (eventualmente dopo aver chiesto, e ricevuto, il permesso di farlo).
un insieme di computer si dice Cluster
I multicomputer sono facili da costruire perché il componente base è un PC con una scheda di rete con alte performance.</li>
</ol>
<h2 id="topologia">TOPOLOGIA<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#topologia" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>È il modo in cui vengono interconnessi i computer tra loro è composto da:</p>
<ul>
<li>nodi, ovvero il computer stesso con CPU memoria e scheda di rete</li>
<li>switch(opzionale), ovvero il dispositivo di instradamento che consente lo scambio di pacchetti tra i dispositivi, è opzionale poiché i nodi possono essere connessi direttamente tra di loro senza uso di quest’ultimi
ci sono diversi tipi di topologia:</li>
</ul>
<h4 id="1-a-stella">1. A stella<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#1-a-stella" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>i quadrati sono i computer che per comunicare tra loro usano uno switch di intermezzo che consente i trasferimenti
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513145257.png" width="auto" height="auto" alt/></p>
<h4 id="3-ad-anello">3. Ad anello<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#3-ad-anello" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>non sono necessari switch poiché ogni computer è collegato con altri 2 e funziona attraverso un sistema di token che se viene preso da uno dei computer ha la possibilità di trasferire le informazioni tra i computer finché non lo posa
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513145444.png" width="auto" height="auto" alt/></p>
<h4 id="4a-grigliagrid-o-mesh">4.A Griglia(grid) o (mesh)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#4a-grigliagrid-o-mesh" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>è una piattaforma bidimensionale altamente scalabile dove il percorso più lungo tra due nodi si chiama diametro e aumenta come la radice quadrata dei due nodi
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513150032.png" width="auto" height="auto" alt/></p>
<h4 id="5-doppio-toro">5. Doppio Toro<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#5-doppio-toro" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>Gli switch sono più interconnessi tra loro permettendo una miglior tolleranza e velocità di instradamento ma con un diametro inevitabilmente più piccolo
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513150230.png" width="auto" height="auto" alt/></p>
<h4 id="6-cubo">6. Cubo<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#6-cubo" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>Struttura tridimensionale regolare
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513150400.png" width="auto" height="auto" alt/></p>
<h4 id="7-ipercubo-scalabile">7. Ipercubo Scalabile<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#7-ipercubo-scalabile" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>Un cubo di dimensione 4 è ottenibile mettendo insieme due cubi di dimensione 3
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513150816.png" width="auto" height="auto" alt/>
Molti computer paralleli usano questa topologia perché il suo diametro cresce linearmente con la sua dimensione: diametro = <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">nn</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span></span></span></span></p>
<h2 id="cluster">CLUSTER<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#cluster" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>sono una serie di computer connessi assieme e si dividono in 2 tipi:</p>
<ul>
<li>centralizzati: sono computer nella stessa stanza e sono uguali</li>
<li>decentralizzati: non sono nella stessa stanza e sono diversi</li>
</ul>
<h2 id="schemi-di-switching">SCHEMI DI SWITCHING<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#schemi-di-switching" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Nei multicomputer sono usati due tipi di schemi di switching.</p>
<h3 id="1-store-and-forward-packet-switching">1. Store-and-forward packet switching<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#1-store-and-forward-packet-switching" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Ogni messaggio è composto da pacchetti che a seconda delle sue priorità, peso ecc… viene instradato e raggiunge il nodo destinatario. È flessibile ed efficiente ma potrebbe verificarsi un aumento dei tempi di latenza nella fase di invio</p>
<h3 id="2-circuit-switching">2. Circuit switching<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#2-circuit-switching" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Nel secondo caso vengono coinvolti degli switch che si scambiano il messaggio tra di loro partendo da un mittente fino a raggiungere lo switch vicino al destinatario, ciò riduce la latenza perché gli Switch non devono salvare l’informazione devono solo fare da “ripetitori”.
Questo sistema richiede una fase di inizializzazione che prende tempo, ma una volta terminata il processo è velocissimo.
Una variante è il wormhole routing, spezza il pacchetto in sottopacchetti e permette a quest’ultimi di iniziare il tragitto prima che sia stato inizializzato il collegamento.</p>
<h2 id="interfacce-di-rete">Interfacce di rete<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#interfacce-di-rete" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Ogni Computer(Nodo) del Multicomputer ha almeno una scheda di rete e una memoria RAM, che serve per memorizzare i pacchetti che entrano ed escono dal nodo
La scheda di rete comprende RAM e DMA
I DMA(Direct Memory Access) sono dei canali di trasferimento diretto dei dati senza uso della CPU
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513152656.png" width="auto" height="auto" alt/></p>
<h2 id="software-di-comunicazione">SOFTWARE DI COMUNICAZIONE<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#software-di-comunicazione" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>si dividono in più livelli</p>
<p><img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513152957.png" width="auto" height="auto" alt/></p>
<h3 id="1-software-di-comunicazione-di-basso-livello">1. Software di comunicazione di basso livello<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#1-software-di-comunicazione-di-basso-livello" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><strong>Le primitive send e receive possono essere bloccanti (sincrone) o non bloccanti (asincrone).</strong>
L’eccessiva copia di pacchetti è il nemico principale delle prestazioni dei multi computer (i pacchetti vengono copiati per varie ragione tra cui evitare perdita di dati, backup ecc..). Per evitare che ciò accada alcuni multi computer accedono direttamente alla scheda di rete per ricevere o inviare dati. Se così non fosse tutta l’operazione di invio/ricezione dati sarebbe gestito dal sistema operativo che dovrebbe fare chiamate multiple di sistema per gestire il tutto, questo porta a creare molteplici copie dei pacchetti   durante il passaggio dati tra utente e kernel.   Problemi: difficile da programmare, rischi di sicurezza poiché si accede direttamente alla scheda di rete, potrebbero esserci tanti processi sullo stesso nodo che vogliono spedire i pacchetti.</p>
<h3 id="2-software-di-comunicazione-a-livello-utente">2. Software di comunicazione a livello utente<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#2-software-di-comunicazione-a-livello-utente" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>I processi sulle diverse CPU di un multicomputer comunicano attraverso lo scambio di messaggi usando Sender e Receiver</p>
<ol>
<li>
<p><strong>SEND</strong>: Questa funzione invia un messaggio ad un processo identificato come destinazione (destination). Quando si chiama la funzione SEND, si specifica il destinatario del messaggio e un puntatore al messaggio stesso (message_pointer). Il chiamante, ovvero il processo che esegue la chiamata SEND, viene bloccato fino a quando il messaggio non viene effettivamente spedito. Questo significa che il processo chiamante rimane in sospeso fino a quando la CPU non ha completato l’invio del messaggio alla destinazione.</p>
</li>
<li>
<p><strong>RECEIVE</strong>: Questa funzione è chiamata da un processo che desidera ricevere un messaggio da un’altra CPU. Quando si chiama la funzione RECEIVE, si specifica l’indirizzo su cui il processo ricevente è in ascolto (address) e un puntatore al buffer in cui memorizzare il messaggio ricevuto (message_pointer). Il processo chiamante viene bloccato fino a quando non arriva un messaggio sulla porta specificata dall’indirizzo. Una volta ricevuto il messaggio, viene copiato nel buffer e il processo chiamante viene sbloccato, consentendogli di procedere con l’elaborazione.
In un multicomputer statico il numero di CPU è noto a priori, quindi il campo address è formato dall’identificativo della CPU e dall’identificativo del processo o della porta sulla CPU selezionata.</p>
</li>
</ol>
<h2 id="chiamate-bloccanti-e-non-bloccanti">CHIAMATE BLOCCANTI E NON BLOCCANTI<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#chiamate-bloccanti-e-non-bloccanti" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Le primitive send e receive possono essere bloccanti (sincrone) o non bloccanti (asincrone).</p>
<ul>
<li>bloccanti significa che tu finchè non termini di fare un’operazione di send o receive non puoi fare altro</li>
<li>non bloccanti il contrario restituendo il controllo al chiamante subito dopo che ha fatto un’operazione di send o receive, lo svantaggio è che il mittente non sa quando il pacchetto è stato inviato e inoltre non può usare il flusso del buffer per inviare altri pacchetti mentre ne sta già inviando uno
Ci sono 3 soluzioni a questo problema</li>
</ul>
<ol>
<li>il Kernel copia il messaggio in un buffer interno</li>
<li>il mittente riceve un interrupt così che può riutilizzare il buffer</li>
<li>mentre il mittente manda un’altro messaggio il buffer si sdoppia creando una sua copia ma mettendo la sua pagina in modalità read-only</li>
</ol>
<p>Il processo mittente può eseguire quindi:</p>
<ol>
<li>
<p>una spedizione bloccante e mantenere bloccata la CPU</p>
</li>
<li>
<p>una spedizione non bloccante con copia (la CPU spreca tempo solo per eseguire una copia)</p>
</li>
<li>
<p>una spedizione non bloccante con interrupt (programmazione difficile)</p>
</li>
<li>
<p>una spedizione non bloccante con copia su scrittura (la CPU spreca tempo anche per la copia di fine processo oltre le scritture richieste)</p>
</li>
</ol>
<p>In un sistema multi-thread la prima è la scelta migliore: mentre il thread che esegue la send è bloccato, gli altri continuano a lavorare.</p>
<p>Il processo destinatario può utilizzare una receive non bloccante(non blocchi quello che fai ma fai una receive)
una receive bloccante comporta una attesa continua e non permette di svolgere altre operazioni nel mentre.</p>
<p>L’arrivo di un messaggio può essere gestito:</p>
<ol>
<li>
<p>tramite interrupt, ma sono difficili da programmare e molto lenti</p>
</li>
<li>
<p>richiamando una procedura poll(), si tratta di una procedura che viene chiamata per verificare se ci sono messaggi in attesa di essere letti</p>
</li>
<li>
<p>attraverso la creazione automatica di un thread (chiamato thread pop-up) che finito il suo compito muore spontaneamente</p>
</li>
<li>
<p>attraverso un interrupt che attiva nella ISR il codice di gestione (questo schema è una versione ibrida dei precedenti che sfrutta l’idea di un thread pop-up senza creare alcun thread, migliorando così le performance, e si chiama messaggi attivi)</p>
</li>
</ol>
<p><img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513163248.png" width="auto" height="auto" alt/></p>
<h2 id="remote-procedure-call-rpc">Remote Procedure Call (RPC)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#remote-procedure-call-rpc" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Il modello a scambio di messaggi è molto conveniente per un sistema operativo multi computer ma soffre di un grave difetto ovvero tutti le comunicazioni (i programmi) utilizzano l’I/O.
Ci sono due entità il chiamante e il chiamato, quando un processo su una macchina 1 ha bisogno di eseguire una procedura presente sulla macchina 2, la macchina 1 entra in attesa e la macchina 2 elabora la procedura, la macchina 1 invia delle info attraverso i parametri e la macchina 2 li invia a sua volta ritornando i risultati
La procedura chiamante è il client e la procedura chiamata è il server
il programma client usa una procedura client stub per chiamare una procedura remota
viceverda il chiamato ha il server stub</p>
<ul>
<li>
<p>il passo 1 è la chiamata da parte del client del client stub, che è una chiamata di procedura locale, con i parametri messi sullo stack nel modo consueto;</p>
</li>
<li>
<p>il passo 2 consiste nell’impacchettamento dei parametri in un messaggio e nell’effettuare una chiamata di sistema per spedire il messaggio (impacchettare i parametri è detto marshaling);</p>
</li>
<li>
<p>nel passo 3, il kernel spedisce il messaggio dalla macchina client a quella server;</p>
</li>
<li>
<p>nel passo 4 il kernel passa il pacchetto in arrivo al server stub;</p>
</li>
<li>
<p>nel passo 5 il server stub chiama la procedura del server. </p>
</li>
</ul>
<p>La risposta effettua lo stesso cammino in direzione opposta.
problemi implementativi:</p>
<ul>
<li>parametri puntatore: il passaggio dei puntatori è impossibile, perché il client ed il server hanno un diverso spazio degli indirizzi</li>
<li>quando viene scambiato un array all’interno dello stack(quindi nei parametri) che non ha una dimensione definita e ha un simbolo di fine conosciuto solo dal client, c’è un errore di array indefinito esempio di simbolo: &quot;<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\0</span></span></span></span></span>&quot;</li>
<li>tipi di dato: non è sempre possibile dedurre i tipi dei parametri, nemmeno con una specifica normale, o dal codice stesso (funzioni polimorfe). Ad esempio la printf.</li>
<li>variabili globali: la procedura chiamante e quella chiamata non possono comunicare per mezzo di variabili globali in quanto non esiste un contesto comune.
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513211157.png" width="auto" height="auto" alt/></li>
</ul>
<h2 id="memoria-condivisa-distribuita">Memoria condivisa distribuita<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#memoria-condivisa-distribuita" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<blockquote class="callout info is-collapsible is-collapsed" data-callout="info" data-callout-fold>
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>definizione di pagina </p></div>
                  <div class="fold-callout-icon"></div>
                </div>
<div class="callout-content">
<p>La pagina è una suddivisione di memoria su parti di dimensioni minori per ottimizzare le operazioni. L’operazione di suddivisione si chiama paging</p>
</div>
</blockquote>
<p>Benché RPC sia interessante, molti programmatori preferiscono un modello di memoria condivisa, e lo vorrebbero utilizzare anche su un multicomputer.
Venne perciò inventata questa DSM(Distributed Shared Memory) che prevede una memoria virtuale per ogni macchina con le proprie pagine e tabelle.
Quando una CPU effettua una LOAD o una STORE su una pagina che non ha, avviene una trap al sistema operativo, che quindi, localizza la pagina, e chiede alla CPU che la possiede correntemente di invalidare la pagina, e spedirla sulla rete di interconnessione. Quando arriva, la pagina viene mappata e viene fatta ripartire l’istruzione che aveva provocato il fault; in effetti, il sistema operativo sta soddisfacendo i fault di pagina della RAM remota, invece che dal disco locale.
La differenza tra una vera memoria condivisa e DSM è illustrata nella Figura. Nella (a) si vede un vero multiprocessore con memoria fisica condivisa implementata tramite hardware; nella (b) si vede DSM implementata dal sistema operativo; nella (c) troviamo DSM implementata da livelli superiori del software.</p>
<p><img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240513220149.png" width="auto" height="auto" alt/></p>
<h2 id="scheduling">Scheduling<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#scheduling" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>In un multiprocessore tutti i processi stanno nella stessa memoria. Quando una CPU finisce il suo task corrente esegue semplicemente un altro processo (tutti i processi posso essere candidati). Gli algoritmi di scheduling per il multi computer e il multi processore sono simili ma non tutti possono essere applicati ad entrambi. Ad esempio un algoritmo che NON FUNZIONA è quello che prevede la lista centralizzata dei processi pronti “ready” perché avendo un multi computer non posso indirizzare adeguatamente i processi in modo sensato perché ciascun processo può essere eseguito solo dalla CPU dove si trova in quel momento e quindi si crea un problema di bilanciamento. Una cosa importante dei multi computer è che quando si crea un nuovo processo esso deve essere posizionato in modo efficiente per non creare troppa disparità nel carico di lavoro.</p>
<h2 id="bilanciamento-del-carico">Bilanciamento del carico<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#bilanciamento-del-carico" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Ci sono degli algoritmi che permettono la gestione dei vari processi dei singoli nodi(computer) visto che è molto difficile controllarli.
ci sono diverse cose da notare per gestire questi algoritmi:
Il fabbisogno di CPU, l’utilizzo di memoria e la quantità di comunicazione con ogni altro processo. 
I possibili obiettivi sono: la minimizzazione dei cicli di CPU sprecati per la carenza di lavoro locale, la minimizzazione della larghezza di banda di comunicazione totale e condizioni eque per gli utenti e i processi.</p>
<h2 id="virtualizzazione">VIRTUALIZZAZIONE<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#virtualizzazione" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>È una tecnica che permette di creare più computer virtuali all’interno di un computer singolo e reale
La virtualizzazione introduce importanti vantaggi:</p>
<ul>
<li>
<p>forte isolamento tra le macchine (isolamento dei malfunzionamenti);</p>
</li>
<li>
<p>minore spazio occupato;</p>
</li>
<li>
<p>minore consumo;</p>
</li>
<li>
<p>minore calore da dissipare;</p>
</li>
<li>
<p>maggiore manutenibilità;</p>
</li>
<li>
<p>possibilità di creare dei checkpoint (punti di ripristino);</p>
</li>
<li>
<p>possibilità di far girare applicazioni legacy su ambienti obsoleti;</p>
</li>
<li>
<p>possibilità di effettuare test delle applicazioni su differenti sistemi operativi senza disporre dell’hardware fisico necessario.</p>
</li>
</ul>
<p>La “modalità kernel”, anche conosciuta come “modalità privilegiata” o “modalità supervisore”, è uno stato di funzionamento dei processori che consente l’esecuzione di istruzioni privilegiate e l’accesso diretto a risorse hardware critici. In questo stato, il processore ha il massimo livello di controllo sul sistema e può eseguire operazioni sensibili, come cambiare le impostazioni di configurazione hardware o gestire la memoria.
Nel contesto dei sistemi operativi, il kernel è il nucleo centrale del sistema che gestisce le risorse hardware e fornisce servizi di base ai processi in esecuzione.</p>
<p>Quando un sistema operativo esegue operazioni critiche o gestisce risorse hardware, spesso lo fa nella modalità kernel per garantire la sicurezza e l’integrità del sistema.</p>
<p>Ogni CPU ha un insieme di istruzioni che si comportano in modo diverso quando vengono eseguite in modalità utente e kernel.
Quando ciò avviene le istruzioni sono dette sensibili mentre quelle istruzioni che posso eseguire solo in modalità kernel sono dette privilegiate e se le provo ad eseguire in una modalità non kernel ottengo una trap (procedura automatica che si attiva quando avviene un eccezione).</p>
<p>Una macchina è virtualizzabile solo se le istruzioni sensibili sono contenute in quelle privilegiate. Ad oggi la virtualizzazione è stata introdotta direttamente sulle CPU commerciali col nome di SVM o VT.</p>
<h2 id="ci-sono-due-tipi-di-hypervisor">CI SONO DUE TIPI DI HYPERVISOR<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#ci-sono-due-tipi-di-hypervisor" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="hypervisor-tipo-1">HYPERVISOR TIPO 1<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#hypervisor-tipo-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Si posiziona come un SO host in modalità kernel e sopra ad esso ci sono tutti i vari sistemi operativi come macchine virtuali che pensano di stare in modalità kernel ma in realtà sono in modalità utente
Quando il SO guest esegue una istruzione sensibile:</p>
<ul>
<li>
<p>se la CPU non ha la VT l’istruzione fallisce e il sistema operativo crasha;</p>
</li>
<li>
<p>altrimenti avviene una trap nel kernel e l’hypervisor può vedere se l’istruzione è stata inviata da una VM del SO guest, in questo caso la esegue, o da un programma utente, in questo caso simula il comportamento dell’hardware reale.
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240514154232.png" width="auto" height="auto" alt/>
<img src="../../../../UNI/ANNO-1/UTILITY/Pasted-image-20240514154247.png" width="auto" height="auto" alt/></p>
</li>
</ul>
<h3 id="hypervisor-di-tipo-2">HYPERVISOR DI TIPO 2<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#hypervisor-di-tipo-2" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>È un software che viene eseguito sopra un SO Host.
Questo Hypervisor interpreta le istruzioni della VM e le traduce sul SO della macchina reale.
Un esempio è VMware ed è eseguito come programma utente.
Questi hypervisor di tipo 2 sfruttano una tecnica di traduzione binaria, che gli permette di prendere i blocchi di istruzioni di base all’interno di un codice e li traduce come ad esempio (JMP, CALL, TRAP..)
Tutte queste istruzioni vengono tradotte come una procedura VMware
Questi blocchi vengono messi nella cache virtuale di VMware e vengono eseguiti alla velocità della macchina fisica</p>
<h3 id="i-due-messi-a-confronto">I DUE MESSI A CONFRONTO<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#i-due-messi-a-confronto" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Tutte le istruzioni sensibili che lavorano anche a livello kernel in un hypervisor di tipo 2 vengono emulate e quindi non vengono direttamente eseguite sul SO della macchina fisica.
Con gli hypervisor di tipo 1 l’approccio trap and emulate con gli hardware VT genera troppi trap e troppi overhead di gestione, invece la loro traduzione come nel hypervisor di tipo 2 é più efficiente
alcuni di tipo 1 però eseguono lo stesso la traduzione binaria comportandosi come quelli di tipo 2</p>
<blockquote class="callout info is-collapsible is-collapsed" data-callout="info" data-callout-fold>
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>differenza tra procedura e funzione </p></div>
                  <div class="fold-callout-icon"></div>
                </div>
<div class="callout-content">
<p>sono entrambi dei blocchi di istruzioni e la differenza è che la funzione ti ritorna un valore invece la procedura non ritorna nulla</p>
</div>
</blockquote>
<h2 id="paravirtualizzazione">Paravirtualizzazione<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#paravirtualizzazione" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Gli hypervisor tipo 1 e 2 funzionano senza modifiche al SO guest, ma con performance non eccellenti.
Un diverso approccio prevede la modifica del codice sorgente del SO guest: invece di eseguire istruzioni sensibili si effettuano chiamate di procedure definite dall’hypervisor.
Quindi l’hypervisor definisce una interfaccia, cioè delle API (Application Program Interface), che i sistemi operativi guest possono attivare. Questo trasforma di fatto l’hypervisor in un microkernel e il SO guest modificato viene detto paravirtualizzato. Le performance ovviamente migliorano poiché le trap si trasformano in system call.</p></article><hr/><div class="page-footer"></div></div><div class="right sidebar"><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div class="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false,&quot;enableRadial&quot;:false}"></div><button class="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div class="global-graph-outer"><div class="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.2,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true,&quot;enableRadial&quot;:true}"></div></div></div><div class="toc desktop-only"><button type="button" class="toc-header" aria-controls="toc-19" aria-expanded="true"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><ul id="list-1" class="toc-content overflow"><li class="depth-0"><a href="#scheduling-dei-multiprocessori" data-for="scheduling-dei-multiprocessori">Scheduling dei multiprocessori</a></li><li class="depth-2"><a href="#time-sharing" data-for="time-sharing">TIME SHARING</a></li><li class="depth-2"><a href="#space-sharing-scheduling" data-for="space-sharing-scheduling">SPACE SHARING SCHEDULING</a></li><li class="depth-2"><a href="#schedulazione-gang" data-for="schedulazione-gang">SCHEDULAZIONE GANG</a></li><li class="depth-1"><a href="#multicomputer" data-for="multicomputer">MULTICOMPUTER</a></li><li class="depth-1"><a href="#topologia" data-for="topologia">TOPOLOGIA</a></li><li class="depth-1"><a href="#cluster" data-for="cluster">CLUSTER</a></li><li class="depth-1"><a href="#schemi-di-switching" data-for="schemi-di-switching">SCHEMI DI SWITCHING</a></li><li class="depth-2"><a href="#1-store-and-forward-packet-switching" data-for="1-store-and-forward-packet-switching">1. Store-and-forward packet switching</a></li><li class="depth-2"><a href="#2-circuit-switching" data-for="2-circuit-switching">2. Circuit switching</a></li><li class="depth-1"><a href="#interfacce-di-rete" data-for="interfacce-di-rete">Interfacce di rete</a></li><li class="depth-1"><a href="#software-di-comunicazione" data-for="software-di-comunicazione">SOFTWARE DI COMUNICAZIONE</a></li><li class="depth-2"><a href="#1-software-di-comunicazione-di-basso-livello" data-for="1-software-di-comunicazione-di-basso-livello">1. Software di comunicazione di basso livello</a></li><li class="depth-2"><a href="#2-software-di-comunicazione-a-livello-utente" data-for="2-software-di-comunicazione-a-livello-utente">2. Software di comunicazione a livello utente</a></li><li class="depth-1"><a href="#chiamate-bloccanti-e-non-bloccanti" data-for="chiamate-bloccanti-e-non-bloccanti">CHIAMATE BLOCCANTI E NON BLOCCANTI</a></li><li class="depth-1"><a href="#remote-procedure-call-rpc" data-for="remote-procedure-call-rpc">Remote Procedure Call (RPC)</a></li><li class="depth-1"><a href="#memoria-condivisa-distribuita" data-for="memoria-condivisa-distribuita">Memoria condivisa distribuita</a></li><li class="depth-1"><a href="#scheduling" data-for="scheduling">Scheduling</a></li><li class="depth-1"><a href="#bilanciamento-del-carico" data-for="bilanciamento-del-carico">Bilanciamento del carico</a></li><li class="depth-1"><a href="#virtualizzazione" data-for="virtualizzazione">VIRTUALIZZAZIONE</a></li><li class="depth-1"><a href="#ci-sono-due-tipi-di-hypervisor" data-for="ci-sono-due-tipi-di-hypervisor">CI SONO DUE TIPI DI HYPERVISOR</a></li><li class="depth-2"><a href="#hypervisor-tipo-1" data-for="hypervisor-tipo-1">HYPERVISOR TIPO 1</a></li><li class="depth-2"><a href="#hypervisor-di-tipo-2" data-for="hypervisor-di-tipo-2">HYPERVISOR DI TIPO 2</a></li><li class="depth-2"><a href="#i-due-messi-a-confronto" data-for="i-due-messi-a-confronto">I DUE MESSI A CONFRONTO</a></li><li class="depth-1"><a href="#paravirtualizzazione" data-for="paravirtualizzazione">Paravirtualizzazione</a></li><li class="overflow-end"></li></ul></div><div class="backlinks"><h3>Backlinks</h3><ul id="list-2" class="overflow"><li><a href="../../../../UNI/ANNO-1/ARCHITETTURA/Architettura-INDICE" class="internal">Architettura INDICE</a></li><li class="overflow-end"></li></ul></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.5.2</a> © 2025</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript">function n(){let t=this.parentElement;t.classList.toggle("is-collapsed");let e=t.getElementsByClassName("callout-content")[0];if(!e)return;let l=t.classList.contains("is-collapsed");e.style.gridTemplateRows=l?"0fr":"1fr"}function c(){let t=document.getElementsByClassName("callout is-collapsible");for(let e of t){let l=e.getElementsByClassName("callout-title")[0],s=e.getElementsByClassName("callout-content")[0];if(!l||!s)continue;l.addEventListener("click",n),window.addCleanup(()=>l.removeEventListener("click",n));let o=e.classList.contains("is-collapsed");s.style.gridTemplateRows=o?"0fr":"1fr"}}document.addEventListener("nav",c);
</script><script type="module">function f(i,e){if(!i)return;function r(o){o.target===this&&(o.preventDefault(),o.stopPropagation(),e())}function t(o){o.key.startsWith("Esc")&&(o.preventDefault(),e())}i?.addEventListener("click",r),window.addCleanup(()=>i?.removeEventListener("click",r)),document.addEventListener("keydown",t),window.addCleanup(()=>document.removeEventListener("keydown",t))}function y(i){for(;i.firstChild;)i.removeChild(i.firstChild)}var h=class{constructor(e,r){this.container=e;this.content=r;this.setupEventListeners(),this.setupNavigationControls(),this.resetTransform()}isDragging=!1;startPan={x:0,y:0};currentPan={x:0,y:0};scale=1;MIN_SCALE=.5;MAX_SCALE=3;cleanups=[];setupEventListeners(){let e=this.onMouseDown.bind(this),r=this.onMouseMove.bind(this),t=this.onMouseUp.bind(this),o=this.resetTransform.bind(this);this.container.addEventListener("mousedown",e),document.addEventListener("mousemove",r),document.addEventListener("mouseup",t),window.addEventListener("resize",o),this.cleanups.push(()=>this.container.removeEventListener("mousedown",e),()=>document.removeEventListener("mousemove",r),()=>document.removeEventListener("mouseup",t),()=>window.removeEventListener("resize",o))}cleanup(){for(let e of this.cleanups)e()}setupNavigationControls(){let e=document.createElement("div");e.className="mermaid-controls";let r=this.createButton("+",()=>this.zoom(.1)),t=this.createButton("-",()=>this.zoom(-.1)),o=this.createButton("Reset",()=>this.resetTransform());e.appendChild(t),e.appendChild(o),e.appendChild(r),this.container.appendChild(e)}createButton(e,r){let t=document.createElement("button");return t.textContent=e,t.className="mermaid-control-button",t.addEventListener("click",r),window.addCleanup(()=>t.removeEventListener("click",r)),t}onMouseDown(e){e.button===0&&(this.isDragging=!0,this.startPan={x:e.clientX-this.currentPan.x,y:e.clientY-this.currentPan.y},this.container.style.cursor="grabbing")}onMouseMove(e){this.isDragging&&(e.preventDefault(),this.currentPan={x:e.clientX-this.startPan.x,y:e.clientY-this.startPan.y},this.updateTransform())}onMouseUp(){this.isDragging=!1,this.container.style.cursor="grab"}zoom(e){let r=Math.min(Math.max(this.scale+e,this.MIN_SCALE),this.MAX_SCALE),t=this.content.getBoundingClientRect(),o=t.width/2,n=t.height/2,c=r-this.scale;this.currentPan.x-=o*c,this.currentPan.y-=n*c,this.scale=r,this.updateTransform()}updateTransform(){this.content.style.transform=`translate(${this.currentPan.x}px, ${this.currentPan.y}px) scale(${this.scale})`}resetTransform(){this.scale=1;let e=this.content.querySelector("svg");this.currentPan={x:e.getBoundingClientRect().width/2,y:e.getBoundingClientRect().height/2},this.updateTransform()}},C=["--secondary","--tertiary","--gray","--light","--lightgray","--highlight","--dark","--darkgray","--codeFont"],E;document.addEventListener("nav",async()=>{let e=document.querySelector(".center").querySelectorAll("code.mermaid");if(e.length===0)return;E||=await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.esm.min.mjs");let r=E.default,t=new WeakMap;for(let n of e)t.set(n,n.innerText);async function o(){for(let s of e){s.removeAttribute("data-processed");let a=t.get(s);a&&(s.innerHTML=a)}let n=C.reduce((s,a)=>(s[a]=window.getComputedStyle(document.documentElement).getPropertyValue(a),s),{}),c=document.documentElement.getAttribute("saved-theme")==="dark";r.initialize({startOnLoad:!1,securityLevel:"loose",theme:c?"dark":"base",themeVariables:{fontFamily:n["--codeFont"],primaryColor:n["--light"],primaryTextColor:n["--darkgray"],primaryBorderColor:n["--tertiary"],lineColor:n["--darkgray"],secondaryColor:n["--secondary"],tertiaryColor:n["--tertiary"],clusterBkg:n["--light"],edgeLabelBackground:n["--highlight"]}}),await r.run({nodes:e})}await o(),document.addEventListener("themechange",o),window.addCleanup(()=>document.removeEventListener("themechange",o));for(let n=0;n<e.length;n++){let v=function(){let g=l.querySelector("#mermaid-space"),m=l.querySelector(".mermaid-content");if(!m)return;y(m);let w=c.querySelector("svg").cloneNode(!0);m.appendChild(w),l.classList.add("active"),g.style.cursor="grab",u=new h(g,m)},M=function(){l.classList.remove("active"),u?.cleanup(),u=null},c=e[n],s=c.parentElement,a=s.querySelector(".clipboard-button"),d=s.querySelector(".expand-button"),p=window.getComputedStyle(a),L=a.offsetWidth+parseFloat(p.marginLeft||"0")+parseFloat(p.marginRight||"0");d.style.right=`calc(${L}px + 0.3rem)`,s.prepend(d);let l=s.querySelector("#mermaid-container");if(!l)return;let u=null;d.addEventListener("click",v),f(l,M),window.addCleanup(()=>{u?.cleanup(),d.removeEventListener("click",v)})}});
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>