l>[!tip]- lista puntata
>- Livello di trasporto
>	- multiplexing 
>	- demultiplexing
>	- Protocolli del livello di trasporto
>		- UDP
>			- Segmento UDP
>			- checksum
>			- senza handshake
>		- TCP
>			- MTU
>			- MSS
>			- segmento TCP
>			- Handshake
>				- 1 via
>				- 2 vie
>			- finestra di ricezione
>			- Numero di sequenza
>			- ACK
>			- Controllo del flusso
>	- Trasferimenti su canali inaffidabili
>		- RDT
>		- GBN
>		- Ripetizione selettiva
>	- Esempi di congestione
>		- caso 1
>		- caso 2
>		- caso 3
>	- Controllo della congestione
>		- end to end
>		- assistito dalla rete
>			- Bit ECN ECE
>	- Gestioni del tasso di invio
>		- AIMD(Additive Increase Multiplicative Decrease)
>		- slow start
>		- congestion avoidance
>		- fast recovery
>	- TCP RENO
>	- TCP CUBIC
>	- TCP VEGAS
>	- TCP è fair?
### Livello di trasporto
- **introduzione breve**
	- livello che consente la comunicazione tra processi su host differenti mediante protocolli e segmenti
- **tecniche di smistamento dei dati mediante IP+porta**
	- multiplexing 
		- effettuato al lato mittente
		- i segmenti di ciascun processo vengono compattati e inviati, differenziati poi da una intestazione
	- demultiplexing
		- effettuato al lato destinatario
		- tramite le intestazioni dei singoli segmenti viene definito a quale processo socket destinare quel determinato segmento
		- si divide in 
			- con connessione
				- vengono creare socket passive
			- senza
				- è sufficiente IP+porta
![[ms-teams_hVpBKBk0sN.png|300]]
![[ms-teams_j0jUvWaTsw.png|300]]

##### UDP
- **definizione**
	- Protocollo di trasporto veloce senza handshake, con ritrasmissione
- **utilizzi**
	- DNS
	- DHCP
	- HTTP/3 con QUIC
- **struttura del segmento**
	- Intestazione, in cui abbiamo porta di origine, porta di destinazione, lunghezza, checksum
		- origine serve solo se si vuole inviare eventualmente una risposta
	- dati dell'applicazione
- **checksum**
	- spazio di dati all'interno di UDP con lo scopo di rilevare errori e eventualmente ritrasmettere 
	- il mittente calcola la checksum e la invia al destinatario
	- il destinatario calcola a sua volta la checksum e la confronta con quella inviata dal mittente
		- se tutti i bit sono a 1 allora non vi sono errori
![[Pasted image 20250406160244.png]]

##### Modello teorico RDT
![[Pasted image 20250406162511.png]]

- **affidabilità con RDT**
	- RDT Reliable Data Transfer, modello astratto che indica come gestire un canale inaffidabile per garantire la corretta trasmissione dei dati è diviso in versioni 
		- esso venne poi usato come idea per TCP
	- 1.0
		- canale affidabile, mittente e destinatario devono solo aspettare di essere interpellati per inviare o ricevere dati
	- 2.0
		- canale inaffidabile ma con segmenti che vengono inviati in ordine, vengono introdotti ACK e NAK 
		- il mittente prima di rimettersi in attesa di inviare un nuovo segmento attende uno di questi due segnali
		- il destinatario invia ACK o NAK se i dati ricevuti sono ok oppure corrotti
		- problematiche:
			- i segnali possono essere anche essi corrotti
			- nel dubbio viene inviato ma presenterebbe delle duplicazioni
	- 2.1
		- introduce numero di sequenza per evitare duplicazioni
		- il numero di sequenza viene usato tra mittente e destinatario per capire se sono sullo stesso numero di sequenza
		- il mittente invia un pacchetto con un numero di sequenza 0 o 1, si aspetta un ACK con lo stesso numero dal destinatario se è differente allora ci sono problematiche
		- sono ancora usati ACK e NAK
	- 2.2
		- rimuove i NAK, se invio un ACK non corrispondente è come se sto inviando un NAK
	- 3.0
		- aggiunge RTT, ovvero una soglia di tempo per attendere un segnale necessario per effettuare una ritrasmissione
		- usata per gestire perdite e non solo errori
- **trasferimento dati con stop and wait  vs pipeline**
	- <font color="#f79646">stop and wait</font> viene inviato un segmento e si attende un riscontro per esso
	- <font color="#f79646">pipeline</font>, vengono inviati in sequenza i segmenti e poi vengono accumulati su una pipe i rispettivi ACK, nel caso del mittente, per il destinatario i veri e propri segmenti
![[Pasted image 20250406184132.png|500]]

- **GBN**
	- protocollo teorico che prevede utilizzo di finestre 
		- per tenere conto dei segmenti confermati, in attesa di conferma, ancora da inviare
		- se in una sequenza di N segmenti un segmento non viene confermato, il mittente dovrà, dopo il timeout rinviare tutti da quel segmento in poi
![[Pasted image 20250406185245.png]]

- **con ripetizione selettiva**
	- migliora la GBN
	- ogni segmento è una istanza a se numerata, non devo reinviare tutta la sequenza ma solo il singolo interessato
![[Pasted image 20250406193400.png]]
#### TCP
- **introduzione**
	- protocollo di trasporto affidabile basato su connessione tra gli host e correzione di errori
- **dettagli sul segmento MSS e MTU**
	- MSS rappresenta la massima dimensione di un segmento, escludendo l'intestazione
	- MTU rappresenta la massima dimensione di un datagramma del protocollo IP che racchiude anche il segmento
![[Pasted image 20250408124654.png|300]]

- **segmento PDU del TCP**
	- si divide in 
		- intestazione
			- numeri di porta origine e destinazione checksum, ack, numero di sequenza, receive window
		- corpo, i dati effettivi
![[Pasted image 20250408130449.png]]

- **numero di sequenza e ACK**
	- ogni byte è numerato sequenzialmente
	- il campo numero di sequenza include il primo byte di sequenza
	- il campo ACK include l'ultimo byte a essere confermato
- **RTT Round Trip Time**
	- soglia di tempo che deve attendere un mittente prima di effettuare un reinvio se non si ricevono segnali 
	- viene stimato calcolando una media degli ACK ricevuti
- **Controllo e gestione del flusso**
	- TCP permette al mittente di gestire il flusso di dati che può ricevere il buffer  del destinatario, per evitare saturazioni del buffer
	- receive window
		- campo dell'intestazione TCP per definire quanti byte può ancora ricevere il buffer del destinatario
![[Pasted image 20250408135957.png|400]]

- **TCP con handshake**
	- procedura che instaura un collegamento sicuro tra due host 
	- malgrado aumenti l'overhead dovuto a questa procedura diminuisce notevolmente la perdita di dati attraverso segnali di ACK scambiati tra le due parti
	- 2 vie
		- il mittente invia una richiesta di collegamento al destinatario
		- il destinatario manda una conferma con un segnale di ACK
		- la connessione è stabilita e i due possono comunicare fino alla chiusura
		- problemi: perdita del segnale di ACK o di richiesta 
	- 3 vie
		- come quello a 2 vie solo che adesso anche il mittente deve inviare a sua volta un ACK dell'ACK del destinatario e per iniziare la sincronizzazione viene usato un Synbit che deve essere uguale tra i due
			- questi ACK sono identificati da 
			- ACKbit 
				- semplice ACK 1=NAK       0=ACK
			- ACKnum
				- indica fino a quale sequenza di byte ha ricevuto i dati
		- Bit di reset 
			- in caso di errori è possibile terminare repentinamente la connessione stabilita
		- Chiusura connessione TCP
			- Viene inviato un Finbit=1
			- il destinatario invierà un Finbit=1+ACK
			- il mittente invia un ACK e basta
![[Pasted image 20250408142333.png]]
![[Pasted image 20250408142831.png]]

- **attacco Syn flood**
	- vengono inviate molteplici richieste di handshake per far crashare un server
	- si risolve con i cookie
		- il client dovrà rispondere con il cookie assegnato altrimenti non alloca memoria
#### Congestione
- **definizione**
	- fenomeno che avviene quando il carico da inviare supera la capacità di risorse che supporta la rete
- **scenario 1**
	- breve descrizione
		- router con buffer illimitato, ogni coppia mittente/destinatario ha il suo collegamento al router
		- se aumenta il troughput più di R/2 si presentano rallentamenti
![[Pasted image 20250410175431.png]]
- **scenario 2**
	- breve descrizione
		- buffer del router limitato 
		- ritrasmissioni presenti al livello di trasporto non di applicazione
		- si divide in 3 sotto-scenari
			- caso 1 ideale, buffer libero
				- i pacchetti vengono inviati regolarmente
				- il mittente sa quando il buffer è pieno
			- caso 2, buffer pieno e conoscenza meno perfetta della situazione
				- vengono scartati pacchetti e ritrasmissioni
			- caso 3, timeout prematuro
				- timeout non impostato correttamente
				- duplicazioni
![[Pasted image 20250410180557.png]]
![[Pasted image 20250410181647.png]]
- **scenario 3**
	- breve descrizione
		- 4 host 
		- percorsi multi hop
		- timeout e ritrasmissioni
	- problematiche
		- host adiacenti a router prendono tutta la banda possibile
![[Pasted image 20250410182434.png]]

- **controllo della congestione 2 approcci**
	- *end-to-end*
		- il controllo della congestione è *demandato solo al mittente*, che effettuerà dei calcoli
			- della finestra di ricezione prende solo ed esclusivamente il cwnd, ovvero i byte che devono ancora essere ACK e anche quelli non inviati
			- calcolando poi cwnd/RTT riesce a definire circa il tasso di invio
			- non preciso
	- *assistito dalla rete*
		- il router invia dei *pacchetti informativi detti choke* al destinatario, lui li rimanda il mittente insieme a eventuali ACK
		- informano del loro stato di congestione
		- usato in TCP ECN
- **gestione del tasso di invio.**
	- concetto di AIMD
		- Additive increase Multiplicative Decrease
		- questo concetto regola dinamicamente gli MSS
		- Maximum Segment Size, ovvero regola quanti segmenti può inviare prima di attendere una ricezione
		- inizia da 1 aumenta additivamente ad ogni RTT e appena avviene un fault gli cwnd vengono dimezzati
![[Pasted image 20250411162431.png]]

- **fasi di gestione del tasso di invio**
	- *slow start*
		- si inizia piano e poi ad ogni RTT cwnd si raddoppia
	-  *congestion avoidance*
		- viene usata una variabile`sstresh` che definisce un limite per cui si smette di crescere esponenzialmente(slow start) ma linearmente
	- *gestione errori*
		- se non si ricevono ACK(timeout)
			- entra in timeout e dimezza `sstresh` e cwnd=1
		- se riceve 1 o 2 ACK duplicati
			- prova semplicemente a ritrasmetterli
		- se invece ne riceve 3 duplicati
			- aumenta notevolmente cwnd per aumentare il tasso di trasmissione
			- poi entra in fast recovery
	- *fast recovery*
		- quando si verifica una perdita, triplo ACK duplicato si entra in fast recovery
		- questa fase dura 1RTT per attendere l'ack del pacchetto perso 
		- quindi si entra in congestion avoidance partendo da 
			- $cwnd=cwnd \ del \ blocco \ precedente+3 \ tutto \ fratto \ 2$
- **evoluzioni TCP**
	- TCP Reno
		- implementazione di TCP che utilizza un algoritmo con fast recovery e dimezzamento di 1 MSS quando si ha un ACK
	- TCP Cubic
		- utilizza $W_{max}$, dimensione della finestra nel momento in cui avviene una congestione
			- successivamente a una congestione viene ogni volta dimezzata la velocità di trasmissione  e viene settata una variabile $K$ nei pressi di $W_{max}$
			- prima di $K$ si cresce velocemente in un valore compreso tra $K$ e $W_{max}$ meno velocemente
			- ogni volta viene causata la congestione
	- TCP Vegas
		- evoluzione di CUBIC
		- calcola una stima e vede ogni volta se viene rispettata effettivamente
	- ECN
		- presente in alcune implementazioni di TCP
		- vengono usate due variabili
			- ECN
				- il router le invia per segnalare congestioni
					- 10 non c'è
					- 11 c'è
			- ECE
				- le invia il destinatario al mittente
				- 1 se c'è
				- 0 se non c'è
![[Pasted image 20250411183520.png|500]]
- **fairness di TCP e UDP**
	- TCP è fair perché il troughput è dato da $R/K$
		- ovvero il numero la capacità del collegamento fratto il numero delle connessioni
	- TCP paralleli
		- se dallo stesso host faccio più socket con più richieste TCP non diventa più fair
	- UDP non è fair perché non può controllare il tasso di trasmissione 
- **Evoluzioni protocolli di trasporto**
	- QUIC
		- usa UDP e al livello di applicazione implementa le varie sicurezze e migliorie
		- tipo TCP ha HOL(Head Of Line blocking) QUIC no
		- essendo più recente è meno supportato
